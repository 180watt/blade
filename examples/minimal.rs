use lame;
use std::slice;

struct Globals {
    modulator: [f32; 4],
    input: lame::TextureView,
    output: lame::BufferPiece,
}

// Using a manual implementation of the trait
// to show what's generated by the derive macro.
impl lame::ShaderData for Globals {
    fn layout() -> lame::ShaderDataLayout {
        lame::ShaderDataLayout {
            bindings: vec![
                (
                    "modulator".to_string(),
                    lame::ShaderBinding::Plain {
                        ty: lame::PlainType::F32,
                        container: lame::PlainContainer::Vector(lame::VectorSize::Quad),
                    },
                ),
                (
                    "input".to_string(),
                    lame::ShaderBinding::Texture {
                        dimension: lame::TextureViewDimension::D2,
                    },
                ),
                (
                    "output".to_string(),
                    lame::ShaderBinding::Buffer {
                        type_name: "Output",
                        access: lame::StorageAccess::STORE,
                    },
                ),
            ],
        }
    }
    fn fill<E: lame::ShaderDataEncoder>(&self, mut encoder: E) {
        encoder.set_plain(0, self.modulator);
        encoder.set_texture(1, self.input);
        encoder.set_buffer(2, self.output);
    }
}

fn main() {
    env_logger::init();
    let context = unsafe {
        lame::Context::init(lame::ContextDesc {
            validation: true,
            capture: true,
        })
        .unwrap()
    };

    let global_layout = <Globals as lame::ShaderData>::layout();
    let shader_source = std::fs::read_to_string("examples/minimal.wgsl").unwrap();
    let shader = context.create_shader(lame::ShaderDesc {
        source: &shader_source,
        data_layouts: &[Some(&global_layout)],
    });

    let pipeline = context.create_compute_pipeline(lame::ComputePipelineDesc {
        name: "main",
        compute: shader.at("main"),
    });

    let extent = lame::Extent {
        width: 16,
        height: 16,
        depth: 1,
    };
    let res_texture = context.create_texture(lame::TextureDesc {
        name: "input",
        format: lame::TextureFormat::Rgba8Unorm,
        size: extent,
        dimension: lame::TextureDimension::D2,
        array_layers: 1,
        mip_level_count: 1,
        usage: lame::TextureUsage::RESOURCE | lame::TextureUsage::COPY,
    });
    let res_view = context.create_texture_view(lame::TextureViewDesc {
        name: "",
        texture: res_texture,
        dimension: lame::TextureViewDimension::D2,
    });

    let buffer = context.create_buffer(lame::BufferDesc {
        name: "output",
        size: 4,
        memory: lame::Memory::Shared,
    });

    let upload_buffer = context.create_buffer(lame::BufferDesc {
        name: "staging",
        size: (extent.width * extent.height) as u64 * 4,
        memory: lame::Memory::Upload,
    });
    {
        let data = unsafe {
            slice::from_raw_parts_mut(
                upload_buffer.data() as *mut u32,
                (extent.width * extent.height) as usize,
            )
        };
        for y in 0..extent.height {
            for x in 0..extent.width {
                data[(y * extent.width + x) as usize] = y * x;
            }
        }
    }

    let mut command_encoder =
        context.create_command_encoder(lame::CommandEncoderDesc { name: "main" });
    command_encoder.start();

    {
        let mut encoder = command_encoder.with_transfers();
        encoder.copy_buffer_to_texture(upload_buffer.into(), 16 * 4, res_texture.into(), extent);
    }
    {
        let mut pc = command_encoder.with_pipeline(&pipeline);
        pc.bind_data(
            0,
            &Globals {
                modulator: [0.2, 0.4, 0.3, 0.0],
                input: res_view,
                output: buffer.at(0),
            },
        );
        pc.dispatch([1, 1, 1]);
    }
    let sync_point = context.submit(&mut command_encoder);

    let ok = context.wait_for(sync_point, 1000);
    assert!(ok);
    let answer = unsafe { *(buffer.data() as *mut u32) };
    println!("Output: {}", answer);
}
